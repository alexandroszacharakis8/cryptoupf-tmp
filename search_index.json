[["ring-theory.html", "A Ring theory", " A Ring theory A ring is a slightly more complex algebraic structure, since it is equipped with two operations, the first of them with the exact same properties of a commutative group operation, whereas the second does not require the existence of inverse. Definition A.1 A ring1 is a triple \\((\\mathbb{K},\\circ,\\ast)\\), where \\(\\mathbb{K}\\) is a set and \\(\\circ\\) and \\(\\ast\\) are operations on \\(\\mathbb{K}\\), that is, functions \\[\\begin{aligned} \\circ : \\phantom{a} &amp; \\mathbb{K}\\times \\mathbb{K}&amp; \\rightarrow &amp; \\phantom{a}\\mathbb{K}&amp; \\qquad\\qquad &amp; \\ast :&amp; \\mathbb{K}\\times\\mathbb{K}&amp; \\rightarrow &amp; \\mathbb{K}\\\\ &amp; (x,y) &amp; \\mapsto &amp; \\phantom{a} x\\circ y, &amp; &amp; &amp; (x,y) &amp; \\mapsto &amp; x\\ast y, \\end{aligned}\\] which additionally satisfy the following properties: \\((\\mathbb{K},\\circ)\\) is a commutative group. \\((\\mathbb{K},\\ast)\\) satisfies the following properties: Associative law: \\((x\\ast y)\\ast z = x\\ast(y\\ast z)\\) for all \\(x,y,z\\in \\mathbb{K}\\). Existence of identity: there exists \\(e\\in \\mathbb{K}\\) such that \\(e\\ast x=x\\ast e=x\\) for all \\(x\\in \\mathbb{K}\\). Such element \\(e\\) is called the identity element of \\(\\ast\\). Commutativity: \\(x\\ast y=y \\ast x\\) for all \\(x,y\\in \\mathbb{K}\\). Distributive law: \\(x\\ast(y\\circ z)=(x\\ast y)\\circ(x\\ast z)\\) for all \\(x,y,z\\in\\mathbb{K}.\\)* Since we have two operations at the same time, we will adopt the additive and multiplicative notation from groups to represent each of them, respectively. That is, we will think of the first operation of a ring as a form of addition and the second as a form of multiplication. On input \\(x,y\\), we write the result of the first operation by \\(x+y\\), and the result of the second by \\(xy\\). The identity elements of each operation are denoted by \\(0\\) and \\(1\\), respectively. The inverse of \\(x\\) with respect to the first operation is denoted by \\(-x\\). The inverse of \\(x\\) with respect to the second operation, if exists, is denoted by \\(x^{-1}\\). The following table summarizes the notation: Operation Operation on input \\(x,y\\) Identity element Inverse of \\(x\\) \\(+\\) \\(x+y\\) \\(0\\) \\(-x\\) \\(\\cdot\\) \\(xy\\) \\(1\\) \\(x^{-1}\\) We consider some examples: \\((\\mathbb{Z},+,\\cdot)\\), with usual integer addition and multiplication, is a ring, since \\((\\mathbb{Z},+)\\) is a group with identity \\(0\\), \\((\\mathbb{Z},\\cdot)\\) verifies associativity, commutativity and existence of identity (\\(1\\)), and it is easy to verify distributivity. Note, however, that \\(\\mathbb{Z}\\) does not contain multiplicative inverses, since for example there is no \\(x\\in\\mathbb{Z}\\) such that \\(2x=1\\). For similar reasons, \\((\\mathbb{Z}_n,+,\\cdot)\\), with modular addition and multiplication, is a ring, for \\(n\\in\\mathbb{N}\\). \\((\\mathbb{Q}[X],+,\\cdot)\\), where \\(\\mathbb{Q}[X]\\) is the set of polynomials with rational coefficients in variable \\(X\\), \\(+\\) is point-wise addition, and \\(\\cdot\\) is point-wise multiplication, is also a ring. The identity elements are the constant polynomials \\(p(X)=0\\) and \\(q(X)=1\\), respectively. Consider the ring \\(\\mathbb{Z}_9\\), with addition and multiplication modulo \\(9\\). The following table gives the multiplicative inverses of each element: \\(x\\) \\(0\\) \\(1\\) \\(2\\) \\(3\\) \\(4\\) \\(5\\) \\(6\\) \\(7\\) \\(8\\) \\(x^{-1}\\) \\(-\\) \\(1\\) \\(5\\) \\(-\\) \\(7\\) \\(2\\) \\(-\\) \\(4\\) \\(8\\) Note that some elements are not invertible, in this case \\(0\\), \\(3\\) and \\(6\\). Those elements in a ring that happen to have a multiplicative inverse receive a special name. Definition A.2 Let \\(\\mathbb{K}\\) be a ring. An element \\(x\\in\\mathbb{K}\\) that has a multiplicative inverse is called a unit. We denote the set of units of \\(\\mathbb{K}\\) by \\(\\mathbb{K}^*\\). Note that the only thing that \\((\\mathbb{K},\\cdot)\\) was missing to be a group is existence of inverses. By restricting ourselves to the subset \\(\\mathbb{K}^*\\) of invertible elements, we have that \\((\\mathbb{K}^*,\\cdot)\\) is a group. Note that, in the previous lesson, we defined \\(\\mathbb{Z}_n^*\\) to be the set of invertible elements of \\(\\mathbb{Z}_n\\), so in this new formulation, we can state that \\(\\mathbb{Z}_n^*\\) is actually the set of units of \\(\\mathbb{Z}_n\\). Moreover, we now know that \\(\\mathbb{Z}_n^*\\) is a group with multiplication modulo \\(n\\). In light of the discussion above, we start this section by asking ourselves the following question. Is it possible to have a ring \\(\\mathbb{K}\\) in which all the elements are invertible? This will never be the case, unless the ring only contains one element, since the additive identity \\(0\\) cannot have a multiplicative inverse otherwise. To see this, assume that there exists \\(x\\in\\mathbb{K}\\) such that \\(0\\cdot x = 1\\). First, \\[0x=(1+(-1))x=x+(-x)=0,\\] using the distributive law and the properties of the multiplicative identity \\(1\\). Then we have that \\(1=0\\). But then, this means that \\[x=1x=0x=0,\\] using the properties of the multiplicative and additive identities. Thus, we conclude that every element is the same. And rings with just one element are not very interesting. So, except for the trivial case, we know that \\(0\\) cannot have an inverse. What about the rest of the elements? In this case, the answer is affirmative: there exist rings in which every non-zero element is invertible, and we call those fields. Definition A.3 A field is a ring in which every non-zero element has a multiplicative inverse in the ring. In an abstract algebra context, the definition of a ring is more general, and what we are defining is known as a commutative ring with unity. Nevertheless, we stick to this definition for simplicity, since it is the only type of ring relevant to us.↩︎ "],["primality-testing.html", "B Primality testing", " B Primality testing Many modern cryptographic schemes require some very large prime numbers, so we are interested in generating these numbers efficiently. The basic strategy is very simple: pick a random number of the desired size, and check whether it is prime. If it is not, pick another. A consequence of the prime number theorem (Proposition ??) is that, on average, we need about \\(\\lambda\\) tries to find a prime of bitlength \\(\\lambda\\), so that’s not too bad. But what about recognizing whether a number is prime or not? This part is solved with a primality test. In this section, we look at some of them. The naive way to check primality is to check if the candidate integer \\(n=O(2^\\lambda)\\) is divisible by any other smaller integer. If that’s not the case, then necessarily \\(n\\) is prime. So, in general, this algorithm runs in time \\(O(n)\\), which is exponential in \\(\\lambda\\). We can do slightly better by observing that it is enough to check divisors up to \\(\\sqrt{n}\\). Proposition B.1 Let \\(n\\in\\mathbb{N}\\). If \\(n\\) is composite, then \\(n\\) has a non-trivial divisor \\(d\\leq\\sqrt{n}\\). Proof. We prove the result by contradiction. Assume that \\(n\\) is composite and has no non-trivial divisor smaller than \\(\\sqrt{n}\\). Since \\(n\\) is composite, it has at least two non-trivial divisors \\(a,b\\in\\mathbb{N}\\), such that \\(ab=n\\). But every divisor is larger than \\(\\sqrt{n}\\), therefore \\[n=ab&gt;\\sqrt{n}\\cdot\\sqrt{n}=n,\\] and thus \\(n&gt;n\\), which is a contradiction. Still, our primality test would run in time \\(O(\\sqrt{n})\\), which is still exponential in \\(\\lambda\\). We need to look for a more efficient approach. We turn our attention to Fermat’s little theorem: Proposition B.2 (Fermat's little theorem) Let \\(p\\) be a prime number. Then, for any \\(x\\in\\mathbb{Z}\\) such that \\(p\\nmid x\\), we have that \\[x^{p-1}\\equiv1\\pmod{p}.\\] This theorem tells us about a condition that all prime numbers verify, which gives us an easy condition to test and discard composite numbers. Given a candidate \\(n\\), choose some \\(x\\in\\mathbb{Z}\\) such that \\(\\gcd(n,x)=1\\), and compute \\[x^{n-1}\\bmod{n}.\\] If the result is not \\(1\\), then we conclude that \\(n\\) is not a prime. This is known as the Fermat primality test, and it is very efficient. But what happens if the result is \\(1\\)? Does this mean that \\(n\\) is a prime? Unfortunately, it is not as simple as this. For example, take \\(n=91\\) and \\(x=3\\). It is easy to verify that \\[3^{90}\\pmod{91}=1,\\] but \\(91=7\\cdot13\\), so it is not a prime. We call the numbers that produce these “false positives” pseudoprimes. Definition B.1 Let \\(n\\in\\mathbb{Z}\\) be a composite number, and let \\(x\\in\\mathbb{Z}\\) such that \\(\\gcd(x,n)=1\\). We call \\(n\\) an \\(x\\)-Fermat pseudoprime if \\[x^{n-1}\\equiv1\\pmod{n}.\\] Moreover, for any \\(x\\) there are many \\(x\\)-Fermat pseudoprimes. Okay, so everybody don’t panic. Fermat’s little theorem tell us that primes verify the condition \\[x^{p-1}\\equiv1\\pmod{p}\\] for every \\(x\\) such that \\(\\gcd(p,x)=1\\). So surely we can find some other base \\(x\\) so that \\(91\\) cannot fool the test. Indeed, \\[5^{90}\\bmod{91} = 64.\\] So that’s it, we are now sure that \\(91\\) is not a prime, because it does not pass the test for \\(x=5\\). Problem solved. Or is it? What if there are some truly evil numbers that can fool the Fermat test for all the possible bases? Definition B.2 Let \\(n\\in\\mathbb{Z}\\) be a composite number. We say that \\(n\\) is a Carmichael number if it is a \\(x\\)-Fermat pseudoprime for every \\(x\\in\\mathbb{Z}\\) such that \\(\\gcd(n,x)=1\\). Unfortunately, there are too many of these Carmichael numbers. For large values of \\(B\\in\\mathbb{N}\\), the number of Carmichael numbers up to \\(B\\) is approximately \\(B^{2/7}\\). This means that a significant amount of numbers will fool our test, even if we run it for all the possible bases. We need a better test. The solution lies on a strengthened version of Fermat’s little theorem. Proposition B.3 Let \\(p\\in\\mathbb{N}\\) be an odd prime, and let \\(p-1=2^st\\) such that \\(2\\nmid t\\). If \\(\\gcd(p,x)=1\\), then either \\[x^t\\equiv1\\pmod{p},\\] or there exists \\(i\\in\\{0,1,\\dots,s-1\\}\\) such that \\[x^{2^it}\\equiv-1\\pmod{p}.\\] Again, the idea is to test our numbers against this result, and see if they satisfy the equations. This version is called the strong Fermat primality test. Observe that, in the worst case, we need to perform \\(s\\) checks, and if \\(p\\) has bitlength \\(\\lambda\\), then \\(s=O(\\lambda)\\), and each check amounts to modular exponentiation, so overall this is efficient. As before, this new test also produces false positives. Definition B.3 Let \\(n\\in\\mathbb{Z}\\) be an odd composite integer, and let \\(n-1=2^st\\). Let \\(x\\in\\mathbb{Z}\\) such that \\(\\gcd(x,n)=1\\). We call \\(n\\) a strong \\(x\\)-Fermat pseudoprime if \\[x^{t-1}\\equiv1\\pmod{n},\\] or there exists \\(i\\in\\{0,1,\\dots,s-1\\}\\) such that \\[x^{2^it}\\equiv-1\\pmod{n}.\\] Exercise B.1 Check that \\(2047\\) is a strong \\(2\\)-Fermat pseudoprime, because it satisfies the first condition, and that \\(91\\) is a strong \\(10\\)-Fermat pseudoprime, because it satisfies the second condition. So why bother with the strong Fermat test, if it has the same flaw? The key point is that, even if we have strong pseudoprimes, the strong Fermat test does not have its version of Carmichael numbers. That is, for any composite number \\(n\\) we will always be able to find a base such that \\(n\\) does not pass the strong test, showing that it is indeed composite. Moreover, most of the bases will do! Proposition B.4 (Monier--Rabin) Let \\(n&gt;9\\) be an odd composite integer. Then, the number of bases \\(x\\) smaller than \\(n\\) such that \\(n\\) is a strong \\(x\\)-Fermat pseudoprime is at most \\(\\frac14\\varphi(n)\\). This is a very strong result. Since \\(\\varphi(n)&lt;n\\), this tells us that, by picking a base in \\(\\mathbb{Z}_n\\) at random, there is only a probability of \\(1/4\\) that the test lies. Of course, we want a smaller probability, so we repeat the test many times. By using \\(\\lambda\\) iterations for different random bases, we bring the error probability down to \\(1/4^\\lambda\\). Observe that this decreases exponentially in \\(\\lambda\\)! To give some concrete numbers, for \\(\\lambda=1024\\), we have that \\[\\frac{1}{4^\\lambda}\\approx 3.094346\\cdot 10^{-67},\\] and this looks like a failure probability that we can live with. Asymptotically, we have an algorithm that runs \\(\\lambda\\) iterations, and each of these is computing \\(O(\\lambda)\\) exponentiations, so in total we have a running cost of \\(O(\\lambda^2)\\) modular exponentiations. This test is known as the Miller–Rabin primality test, and it is in essence what is used in practice to check for primality, due to its high efficiency and almost-perfect reliability. If you are still concerned about the error probability, there are some alternatives that never produce erroneous results, while still running in polynomial time. However, they are much slower than the Miller–Rabin test, which is why they are not often used in practice.2 Agrawal, M., Kayal, N., &amp; Saxena, N. (2004). PRIMES is in P. Annals of mathematics, 781-793.↩︎ "],["polynomial-interpolation.html", "C Polynomial interpolation", " C Polynomial interpolation We start from a very well-known idea: two different points in a plane determine a line. Or equivalently: given two different points in a plane, there is exactly one line that contains both. More formally, let \\((x_0,y_0)\\) and \\((x_1,y_1)\\) be points in \\(\\mathbb{R}^2\\), such that \\(x_0\\neq x_1\\).3 Then there is a unique polynomial \\(p(X)\\) of degree at most \\(1\\) such that \\[p(x_0)=y_0,\\qquad \\text{and} \\qquad p(x_1)=y_1.\\] Although can find this polynomial by finding the slope of the line, we will show another approach that yields the same result, that we will later generalize to a higher number of points. Consider the following simpler problem. Problem 7. Given \\(x_0,x_1\\in\\mathbb{R}\\), find a polynomial \\(\\ell_0(X)\\) of degree at most \\(1\\) such that \\[\\ell_0(x_0)=1,\\qquad\\text{ and }\\ell_0(x_1)=0.\\] The simplest idea to achieve the second condition is to make \\(x_1\\) a root of the polynomial. Note that, since the degree must be at most \\(1\\), the polynomial will have at most one root, making \\(x_1\\) the only root. Let us then consider the polynomial \\[\\hat\\ell_0(X)=X-x_1.\\] Clearly this polynomial satisfies the second condition, but it fails at the first, since \\[\\hat\\ell_0(x_1)=x_0-x_1,\\] which might be different from \\(1\\). Thus, to ensure the second condition, we rescale the polynomial by dividing by the value at \\(x_0\\): \\[\\ell_0(X)=\\frac{X-x_1}{x_0-x_1}.\\] This new polynomial is indeed a solution for the problem. Similarly, we can find another polynomial \\(\\ell_1(X)\\) that is \\(0\\) at \\(x_0\\) and \\(1\\) at \\(x_1\\). Finally, the solution to our original problem will be \\[p(X)=y_0\\ell_0(X)+y_1\\ell_1(X).\\] Exercise C.1 Check that this polynomial has degree at most \\(1\\), that \\(p(x_0)=y_0\\) and \\(p(x_1)=y_1\\). It is easy to check that this polynomial verifies the conditions above. We say that this line is an interpolation of the points. This idea can be generalized to polynomial of any degree. That is, there is a unique parabola (polynomial of degree \\(2\\)) that contains three given points in the plane. There is a degree-\\(3\\) polynomial that contains four given points, and so on. Moreover, this also works over a finite field \\(\\mathbb{F}_p\\) for any prime \\(p\\), when the operations are considered modulo \\(p\\) and division is inversion modulo \\(p\\). Proposition C.1 Let \\(n\\in\\mathbb{N}\\), and let \\(p\\in\\mathbb{Z}\\) be a prime number. Consider \\(n+1\\) pairs \\((x_i,y_i)\\), for \\(i=0,\\dots,n\\), of points in \\(\\mathbb{F}_p\\), such that the \\(x_i\\) are pairwise different. Then, there is a unique polynomial \\(p(X)\\) of degree at most \\(n\\) such that \\[p(x_i)=y_i,\\qquad\\text{ for all }i=0,\\dots,n.\\] The polynomial \\(p(X)\\) is called the Lagrange interpolation polynomial of degree \\(n\\) relative to the points \\((x_i,y_i)\\) for \\(i=0,\\dots,n\\). The strategy to build this polynomial explicitly is to generalize what we have done before for two points. That is, we first want to solve the following problem. Problem 8. Given \\(x_0,\\dots,x_n\\in\\mathbb{F}_p\\), find polynomials \\(\\ell_i(X)\\), for \\(i=0,\\dots,n\\), of degree at most \\(n\\) such that \\[\\ell_i(x_i)=1,\\qquad\\text{ and }\\ell_i(x_j)=0, \\qquad \\text{ for all }j\\neq i.\\] That is, we want polynomials such that each of them is \\(1\\) at at one of the points and \\(0\\) at the rest of the points. For the polynomial \\(\\ell_i(X)\\), we ensure that all \\(x_j\\neq x_i\\) are roots of the polynomial. We consider: \\[\\hat\\ell_i(X)=\\prod_{j\\neq i}(X-x_j).\\] This polynomial has degree \\(n\\), since it has \\(n\\) factors, each of degree \\(1\\). Moreover, it clearly satisfies that \\(\\hat\\ell_i(x_j)=0\\) if \\(j\\neq i\\). However, we still run into the problem that it produces the wrong value at \\(x_i\\). Indeed, \\[\\hat\\ell_i(x_i)=\\prod_{j\\neq i}(x_i-x_j).\\] We solve the issue by dividing the polynomial by this value, and thus we consider the polynomial \\[\\ell_i(X)=\\frac{\\prod_{j\\neq i}(X-x_j)}{\\prod_{j\\neq i}(x_i-x_j)}=\\prod_{j\\neq i}\\frac{(X-x_j)}{x_i-x_j}.\\] The polynomials \\(\\ell_i(X)\\) are known as the Lagrange basis polynomials, as we can now use them as a basis for building any interpolation polynomial relative to the points \\(x_0,\\dots,x_n\\). Indeed, we consider the linear combination \\[p(X)=\\sum_{i=0}^n y_i\\ell_i(X).\\] It is easy to check that this polynomial satisfies that \\[p(x_i)=y_i\\] for all \\(i=0,\\dots,n\\). Moreover, since the degree of the \\(\\ell_i(X)\\) is \\(n\\), and addition of the polynomials or multiplication by constant do not increase the degree (although they might reduce it), the polynomial \\(p(X)\\) will have degree at most \\(m\\). Therefore, this is the Lagrange interpolation polynomial that we were looking for. Exercise C.2 Compute the Lagrange interpolation polynomial corresponding to the points \\((0,1),(1,-1),(2,2),(3,8)\\). We require the \\(x\\)-coordinates to be different because we want to formulate this in terms of functions, and a function cannot have two outputs for the same input.↩︎ "],["refreshers.html", "D Refreshers D.1 Set notation D.2 Probability theory D.3 Asymptotic notation D.4 Polynomial division", " D Refreshers D.1 Set notation A set is a well-defined collection of objects. Such objects are said to be elements of the set, or that they belong to the set. For example, the set of the vowels is \\[V=\\{\\text{a},\\text{e},\\text{i},\\text{o},\\text{u}\\}.\\] In the above line we are giving a name to the set, \\(V\\), and we are specifying the list of its elements: a, e, i, o and u. When describing a set explicitly, we write the list of its elements between braces \\(\\{\\hspace{0.1cm} \\}\\). Two sets are equal if they have exactly the same elements. An element cannot belong ‘twice’ to a set. Therefore, we can say that \\[V=\\{\\text{a},\\text{e},\\text{i},\\text{o},\\text{u}\\}=\\{\\text{u},\\text{o},\\text{i},\\text{e},\\text{a}\\}=\\{\\text{a},\\text{a},\\text{e},\\text{e},\\text{e},\\text{i},\\text{o},\\text{u}\\}.\\] The symbol \\(\\in\\) indicates membership of an element in a set. For example, we can write a \\(\\in V\\), because a belongs to the set \\(V\\). On the other hand, we have that b \\(\\not\\in V\\), since b is not any of the elements of \\(V\\). There are some number sets that show up very frequently, so we give them special names. \\(\\mathbb{N}\\): set of natural numbers. \\(\\mathbb{Z}\\): set of integer numbers. \\(\\mathbb{Q}\\): set of rational numbers. \\(\\mathbb{R}\\): set of real numbers. \\(\\mathbb{C}\\): set of complex numbers. Observe that, unlike in the prior examples, all these sets are infinite, that is, they have an infinite number of elements. Obviously we cannot describe an infinite set explicitly, as we have done with the set of vowels. What we can do is refer to other sets that we have already defined and define restrictions on them. For example, we can define the set of even natural numbers as the set of natural numbers that are multiples of \\(2\\). Formally, we write this set as \\[\\{n\\in \\mathbb{N}\\mid n=2k\\text{ for some }k\\in\\mathbb{N}\\}.\\] Here we have introduced some new notation. Instead of explicitly enumerating all the elements of a set, we give some conditions. We read the description above as ‘the set of elements of the form indicated on the left of the vertical line, such that they verify the condition on the right’. In this case, the set of natural numbers such that they are of the form \\(2k\\) for some natural value of \\(k\\). Similarly, we can define the set of all real numbers greater than \\(5\\) in the following way: \\[\\{x\\in \\mathbb{R}\\mid x&gt;5\\}.\\] We denote the size (number of elements) of a set \\(S\\) by \\(\\#S\\). We can produce new sets by considering the product of known sets: given two sets \\(S,T\\), we define the set \\(S\\times T\\) as the set whose elements are the pairs \\((s,t)\\), where \\(s\\in S\\) and \\(t\\in T\\). For example, \\[\\{0,1\\}\\times\\{0,1,2\\}=\\{(0,0),(0,1),(0,2),(1,0),(1,1),(1,2)\\}.\\] Observe that \\(\\#(X\\times Y)=\\#X\\cdot\\#Y\\). It is easy to generalize this definition to products of three or more sets. In particular, given a set \\(S\\), we define \\[S^n=\\underbrace{S\\times S\\times \\dots \\times S}_{n\\text{ times}}\\] In this course, we will often use the set \\(\\{0,1\\}\\) of possible bits, the set \\(\\{0,1\\}^\\ell\\) of possible bitstrings of length \\(\\ell\\), and the set \\(\\{0,1\\}^*\\) of bitstrings of any length. Observe that \\[\\#\\{0,1\\}=2,\\qquad\\#\\{0,1\\}^\\ell=2^\\ell,\\qquad \\#\\{0,1\\}^*=\\infty.\\] Exercise D.1 Write these sets using implicit notation: The set of complex numbers with real part equal to \\(1\\). The set of pairs, where the first component of the pair is a rational number and the second component is an odd natural number. The set of bitstrings of length \\(10\\) with exactly \\(5\\) zeros. D.2 Probability theory We will deal with probability distributions over finite sets. In particular, recall that the uniform distribution over a set \\(S\\) is the probability distribution that assigns the same probability \\(1/\\#S\\) to each element of \\(S\\). We denote sampling an element \\(x\\) from the uniform distribution over \\(S\\) by \\[x\\gets S.\\] For example, the notation \\[\\mathbf b\\gets \\{0,1\\}^{128}\\] means that \\(\\mathbf b\\) is a uniformly random bitstring of length \\(128\\). Given an event \\(A\\), we denote the probability of \\(A\\) by \\(\\Pr[A]\\). Given two events \\(A,B\\), we denote the probability of \\(A\\) conditioned on \\(B\\) by \\(\\Pr[A|B]\\), and if \\(\\Pr[B]\\neq0\\) we have that \\[\\Pr[A|B]=\\frac{\\Pr[A\\cap B]}{\\Pr[B]},\\] where \\(\\Pr[A\\cap B]\\) means the probability of both \\(A\\) and \\(B\\) happening. Recall that, if \\(A\\) and \\(B\\) are independent events, then \\[\\Pr[A\\cap B]=\\Pr[A]\\cdot\\Pr[B].\\] Exercise D.2 Compute the probability of a random bitstring of length \\(4\\) being the string \\(1110\\). D.3 Asymptotic notation Asymptotic notation allows us to easily express the asymptotic behaviour of functions, that is, how the function changes for arbitrarily large inputs, with respect to some other function. For example, take the functions defined by \\[f(x)=x,\\qquad\\qquad g(x)=x^2.\\] Both tend to infinity as \\(x\\) tends to infinity, but the second does it “faster”. More precisely, let \\[f,g:\\mathbb{N}\\rightarrow\\mathbb{N}\\] be two functions. We write \\[f(x)=O(g(x))\\] when there is some \\(N,M\\in\\mathbb{N}\\) such that, for all \\(x&gt;N\\), we have \\[f(x)\\leq M\\cdot g(x).\\] We read this as “\\(f\\) is big-O of \\(g\\)”. Then, back to the initial example, we can say write \\[x=O(x^2).\\] Note that, because the big-O notation “absorbs” constants into \\(M\\), we can write \\[2x=O(x),\\] even though \\(2x\\geq x\\) for \\(x\\in\\mathbb{N}\\). Big-O notation is useful for representing bounds on the growth speed of a function. By saying, for example, that a function \\(f\\) satisfies \\[f(x)=O(x^3),\\] we are saying that, at worst, the function \\(f\\) grows as fast as a cubic polynomial. Therefore, in particular, it will not grow as fast as a polynomial of degree \\(4\\), or an exponential function like \\(2^x\\). We recall that logarithmic functions grow slower than polynomials of any degree, and polynomials of any degree grow slower than exponential functions. Given two polynomials of different degrees, the one with the higher degree grows faster. Exercise D.3 Decide whether each of these statements is true or false. \\(10^{10}x^3=O(x^4)\\). \\(10^x=O(x^4)\\). \\(\\log(x)=O(x\\log x)\\). \\(4^x=O(2^x)\\). D.4 Polynomial division Consider two polynomials \\[\\begin{split} &amp; A(X)=a_kX^k+a_{k-1}X^{k-1}+\\dots+a_1X+a_0, \\\\ &amp; B(X)=b_{\\ell}X^{\\ell}+b_{\\ell-1}X^{\\ell-1}+\\dots+b_1X+b_0, \\\\ \\end{split}\\] where \\(k\\geq\\ell\\). Then, we have the following result. Proposition D.1 Let \\(A(X)\\) and \\(B(X)\\) be the polynomials defined above. Then, there exist polynomials \\(Q(X)\\) and \\(R(X)\\) such that \\[A(X)=B(X)Q(X)+R(X),\\] where the degree of \\(R\\) is smaller than \\(\\ell\\). In this case, \\(Q\\) is called the quotient and \\(R\\) is called the remainder of the division. The algorithm is very similar to the algorithm of integer division. The idea is to try to find factors such that, when multiplied by \\(B(X)\\), allow us to remove the highest-degree term left in \\(A(X)\\), and use these terms to build \\(Q(X)\\). Although very simple, the idea is cumbersome to explain for general polynomials, so we illustrate it with an example. Let \\[A(X)=3X^5+X^4+2X^2+7,\\qquad B(X)=X^3+X^2+X.\\] We arrange them in the usual diagram: \\[\\begin{array}{rrrrrrl} 3X^5 &amp; +x^4 &amp; &amp; +2x^2 &amp; &amp; +7 \\qquad &amp; |\\quad X^3+X^2+X\\\\ &amp;&amp;&amp;&amp;&amp;&amp; \\overline{\\phantom{|\\quad X^3+X^2+X}} \\\\ \\end{array}\\] We want to remove \\(3X^5\\), so we try to find a factor \\(f(X)\\) such that \\(f(X)X^3=3X^5\\). Thus, we choose \\(f(X)=3X^2\\), multiply it by \\(B(X)\\), and subtract the result from \\(A(X)\\), obtaining a lower-degree polynomial: \\[\\begin{array}{rrrrrrl} 3X^5 &amp; +X^4 &amp; &amp; +2X^2 &amp; &amp; +7 \\qquad &amp; |\\quad X^3+X^2+X\\\\ &amp;&amp;&amp;&amp;&amp;&amp; \\overline{\\phantom{|\\quad X^3+X^2+X}} \\\\ &amp; -2X^4 &amp; -3X^3 &amp; +2X^2 &amp; &amp;+ 7 \\qquad &amp; 3X^2\\\\ \\end{array}\\] We now look at the new polynomial, \\(-2X^4-3X^3+2X^2+7\\), and again try to remove the highest-degree monomial, which we achieve by multiplying \\(X^3\\) by \\(-2X\\). \\[\\begin{array}{rrrrrrl} 3X^5 &amp; +X^4 &amp; &amp; +2X^2 &amp; &amp; +7 \\qquad &amp; |\\quad X^3+X^2+X\\\\ &amp;&amp;&amp;&amp;&amp;&amp; \\overline{\\phantom{|\\quad X^3+X^2+X}} \\\\ &amp; -2X^4 &amp; -3X^3 &amp; +2X^2 &amp; &amp;+ 7 \\qquad &amp; 3X^2-2X\\\\ &amp;&amp;&amp;&amp;&amp;&amp; {\\phantom{|\\quad X^3+X^2+X}} \\\\ &amp; &amp; -X^3 + 4X^2 &amp;&amp;&amp;+ 7 \\qquad &amp; \\\\ \\end{array}\\] Again, we want to remove the term \\(-X^3\\), so we multiply \\(B(X)\\) by \\(-1\\): \\[\\begin{array}{rrrrrrl} 3X^5 &amp; +X^4 &amp; &amp; +2X^2 &amp; &amp; +7 \\qquad &amp; |\\quad X^3+X^2+X\\\\ &amp;&amp;&amp;&amp;&amp;&amp; \\overline{\\phantom{|\\quad X^3+X^2+X}} \\\\ &amp; -2X^4 &amp; -3X^3 &amp; +2X^2 &amp; &amp;+ 7 \\qquad &amp; 3X^2-2X-1\\\\ &amp;&amp;&amp;&amp;&amp;&amp; {\\phantom{|\\quad X^3+X^2+X}} \\\\ &amp; &amp; -X^3 + 4X^2 &amp;&amp;&amp;+ 7 \\qquad &amp; \\\\ &amp;&amp;&amp;&amp;&amp;&amp; {\\phantom{|\\quad X^3+X^2+X}} \\\\ &amp; &amp; &amp; 5X^2 &amp; +X &amp; +7 \\qquad &amp; \\\\ \\end{array}\\] Since the degree of the current dividend is smaller than the degree of the divisor, we are done. We conclude that the quotient of the division of \\(A(X)\\) by \\(B(X)\\) is \\[3X^2-2X-1,\\] and the remainder is \\[5X^2+X+7.\\] Note that the above example works in \\(\\mathbb{Q}\\), but in general operations on the coefficients must take into account which field we are in. For example, if our coefficients are in \\(\\mathbb{F}_5\\), we cannot “divide” by \\(3\\), but we can find the inverse of \\(3\\) modulo \\(5\\), and we must ensure that every coefficient is reduced modulo \\(5\\). "],["sagemath-cookbook.html", "E SageMath Cookbook Installing and running E.1 Basic Operations E.2 Bits, Bytes and Encoding E.3 Symmetric Key Cryptography E.4 Number theory E.5 Groups and Fields E.6 Polynomials E.7 RSA E.8 Safe Prime Groups E.9 Diffie Hellman Key Exchange E.10 ElGamal over Safe Prime Groups E.11 Elliptic Curve Cryptography: secp256k1 Curve E.12 Secret Sharing E.13 Threshold Cryptography E.14 Zero Knowledge Proofs", " E SageMath Cookbook In this appendix we provide a SageMath “cookbook” that contains small self-contained code snippets that are usefull for the course. You can refer to the docs for a more in-depth documentation. We emphasize that the “recipes” presented in this Appendix should under no circumstances be used in the real world. Creating secure cryptographic protocols is a notoriously hard task which needs to follow very specific guidelines. These code snippets make a lot of simplifications and are meant to be used only for educational purposes in the context of this course. Installing and running Installation depends on the operating system you are using. Pleaser refer to this guide for detailed instructions. To launch SageMath simply type sage on a terminal/command prompt. If you are familiar with python’s Jupyter Notebook you can run sage -n jupyter to use it. When in the sage environment, you can simply start coding interactively. You can also edit and save .sage files with any text editor/IDE. To load .sage files, open an interactive sage shell and type load('filename.sage'). You can look into the Guided Tour to get familiarized with sage. If you have little familiarity with python, chances are that you won’t need to study anything more to understand and write code! E.1 Basic Operations In this subsection we give a short overview for handling basic arithmetic and comparison operations. Arithmetic Operations In the next recipe we show how to perform arithmetic operations in sage. Note that exponentiation can also be done using the ^ operator (in contrast to python that uses the ** operator). a = 42 b = 9 # Basic arithmetic operations add = a + b assert add == 51 sub = a - b assert sub == 33 mul = a * b assert mul == 378 div = a / b assert div == 14/3 # We can convert a to a float div_float = float(a / b) quot = a // b assert quot == 4 mod = a % b assert mod == 6 # can also use a**4 exp = 2^10 assert exp == 1024 # the second argument is the base. # default is e lg = log(1024, 2) assert lg == 10 # computing n-th roots # sqrt is for symbolic calculations sq4 = 81^(1/4) assert sq4 == 3 Comparison Operations As demonstrated in the next recipe, comparison operations work as expected. res = (1 &gt; 1) assert not res res = (1 &gt;= 1) assert res res = (12 &lt; 15) assert res res = (10 &lt;= 15) assert res res = (20 == 21) assert not res res = (True != False) assert res E.2 Bits, Bytes and Encoding In this subsection we present ways to handle low level builiding blocks such as bits, bytes and ASCII Encoding. Bitwise Operations The next recipe shows how to perform bitwise logical operations (AND, OR, XOR etc). # 0b0101 represent a binary number # 0x65 represents a hexadecimal number # to see different representations use the functions bin(n) and hex(n) # a = 11, b = 12 a = 0b1011 b = 0b1100 # AND log_and = a &amp; b assert log_and == 0b1000 # OR log_or = a | b assert log_or == 0b1111 # XOR # SageMath uses &quot;^^&quot; for xor since &quot;^&quot; is used for exponentiation log_xor = a ^^ b assert log_xor == 0b0111 # left and right shift lshift = a &lt;&lt; 2 assert lshift == 0b101100 rshift = a &gt;&gt; 2 assert rshift == 0b10 Encode/Decode ASCII The next recipe shows how to encode/decode to ASCII. You can find an ASCII table here. from sage.crypto.util import bin_to_ascii, ascii_to_bin msg = &quot;I need to be encoded&quot; ascii_bits = ascii_to_bin(msg) msg_prime = bin_to_ascii(ascii_bits) assert msg == msg_prime Sampling Random Bitstring The next recipe shows how to sample random bitstrings. There are many ways to do this actually. We use a more functional style when possible to keep the code cleaner. import random length = 128 def rand_bitstring(n): &quot;&quot;&quot; Samples n random bits and represents them as str. &quot;&quot;&quot; # loop length times and in each loop sample a 0/1 value. # Then join the sampled values return &#39;&#39;.join(str(random.choice([0, 1])) for _ in range(n)) Sampling Random Bytes Same thing, but this time with bytes. n = 32 def rand_bytes(n): &quot;&quot;&quot; Samples n random byte. &quot;&quot;&quot; # loop length times and in each loop sample a [0..256) value. # Then join the sampled values return b&#39;&#39;.join(randrange(0,256).to_bytes() for _ in range(n)) Xoring bytes In the next recipe we show how we can XOR two byte strings. Recall that for binary numbers, one can directly use the operator ^^ (but be carefull to first convert to numbers if needed!). def xor_bytes(lbytes, rbytes): &quot;&quot;&quot; XORs two sets of bytes. It assumes they have the same length. &quot;&quot;&quot; if len(lbytes) != len(rbytes): raise ValueError(&quot;Bytes must have equal length&quot;) # Apply the XOR (^^) operator for each pair of bytes # and collect the result in bytes return bytes(x ^^ y for x, y in zip(lbytes, rbytes)) E.3 Symmetric Key Cryptography In this subsection we present various recipes that are related to symmetric key cryptography. One-Time-Pad The next recipe shows how to implement OTP in sage. As you can see, it is quite easy! The only difficulty is handling the types (ascii encodings, bytes etc). Depending on semantics, you might want to modify the following code snippet, for example you might want to directly apply one-time-pad on binary numbers. import random # For ascii encoding/decoding from sage.crypto.util import bin_to_ascii, ascii_to_bin def xor(a, b): &quot;&quot;&quot; Helper function to apply the xor function to two strings representing binary numbers. It returns an str with the result. &quot;&quot;&quot; # apply the function xor (^^) elementwise to a and b and collects the result # we need first to convert the elements to ints to apply the ^^ function # note that the bigger list is trimmed by the list map c = list(map(lambda a_i, b_i: str(int(a_i) ^^ int(b_i)), a, b)) return &quot;&quot;.join(c) def otp_keygen(length): &quot;&quot;&quot; Sample an OTP key. This is a random bitstring of length &quot;length&quot; &quot;&quot;&quot; # loop length times and in each loop sample a 0,1 value. # Then join the sampled values return &#39;&#39;.join(str(random.choice([0, 1])) for _ in range(length)) def otp_encrypt(key, message): &quot;&quot;&quot; One time pad encryption. The key is an str representing binary values and the message an str. The outputted ciphertext is an ASCII encoded str. &quot;&quot;&quot; # Get the ascii bits of the message message_bits = str(ascii_to_bin(message)) if len(key) &lt; len(message_bits): raise ValueError(&quot;OTP Key is too small for the message&quot;, message) return # apply the bitwise xor function ciphertext = xor(message_bits, key) # We decode the ciphertext so that the types of m, c are the same. #This way we can implement decryption by simply calling encrypt(key, ciphertext) return bin_to_ascii(&quot;&quot;.join(ciphertext)) def otp_decrypt(key, ciphertext): &quot;&quot;&quot; One time pad decryption. This simply calls encrypt on the same arguments. &quot;&quot;&quot; return otp_encrypt(key, ciphertext) Here is how one could use the above otp implementation. # We use the otp.sage recipe load(&#39;otp.sage&#39;) # sample a long OTP key k = otp_keygen(32768) m = &quot;I need to be encrypted with perfect secrecy!&quot; # encrypt c = otp_encrypt(k, m) # decrypt m_prime = otp_decrypt(k, c) assert m == m_prime PRNG: SHA256 The next recipe shows how to construct a PRNG. There are various ways to do this. A simple one, that is presented here, consists of taking a seed s and compute H(s||1)||H(s||2)||...||H(s||k) where \\(H\\) is a cryptographic hash function. You choose an appropriate k to define the desired PRNG output length. For the hash function, we use the SHA256 hash function. The implementation is taken from the hashlib library. You can use a hash function of your choice instead, just make sure it is cryptographically secure! from hashlib import sha256 def sample_seed(n): &quot;&quot;&quot; Samples a random seed. The length represents the number of bytes of the seed. The output is given in bytes. &quot;&quot;&quot; # sample n random bytes return b&#39;&#39;.join(randrange(0,256).to_bytes() for _ in range(n)) def sha256_prg(seed, length): &quot;&quot;&quot; Uses hash function sha256 to construct a PRNG. sha256 maps bytes of arbitrary lengths to a fixed 256 bit (=32 byte) output. To construct a PRNG using a seed s compute: sha256(seed||0), sha256(seed||1), ..., sha256(seed||k) until the length is greater than or equal to length. Then truncate any remaining bytes to get the desired output. &quot;&quot;&quot; # Initialize output as an empty byte string output = b&#39;&#39; # The counter concatenated to seed in each iteration counter = 0 while len(output) &lt; length: # prepare the input seed || counter hash_input = seed + counter.to_bytes() # hash (seed || counter) using sha256 hash_output = sha256(hash_input).digest() # add to output and prepare counter for next round output += hash_output counter += 1 return output[:length] Here how you can actually use the above code. # We use the sha256_prng.sage recipe load(&#39;sha256_prng.sage&#39;) # sample a 256bit (=32 byte) length seed seed = sample_seed(32) # output a 8192bit (1024 bytes) pseudorandom byte stream output = sha256_prg(seed, 1024) Block Ciphers: AES128 In the next recipe, we show how to use AES128 block cipher via the Crypto.Cipher implementation. As we have discussed, you should NEVER use block ciphers in ECB mode! In the following implementation we seem to be using AES with ECB mode but this is not the case. We simply do that to get access to the “pure” (i.e. no mode of operation) AES block cipher. Whenever we use it, we always encrypt a single block (equivalent to running AES). The reason for doing it this way, is because the libraries that implement block ciphers also implement modes of operations and the interface requires to choose which mode we want to use. On our usecase, we want to demonstrate later how to implement modes of operations ourselves and utilizing the existing library this way is the easiest way to do this. Alternatively, we could re-implement AES, but this is a fairly complex construction on its own. # We use the Crypto implementation of AES from Crypto.Cipher import AES # We use the random_bytes.sage and xor_bytes recipes load(&#39;random_bytes.sage&#39;) load(&#39;xor_bytes.sage&#39;) def aes_keygen(): &quot;&quot;&quot; Samples random 32 bytes (=128 bits) for an AES128 key &quot;&quot;&quot; return rand_bytes(32) def aes_enc(key, message_block): &quot;&quot;&quot; Runs the AES128 encryption on message_block with the specified key. The length of message_block must be 32. &quot;&quot;&quot; if len(message_block) != 32: raise ValueError(&quot;AES message must be exactly 32 bytes!&quot;) # CAUTION: We do not actually use ECB mode! The cipher object needs a mode in order # to be initialized and since we want the &quot;pure&quot; permutation we initialize with ECB Mode # and always use it to encrypt blocks of size exactly 32. This is equivalent to running # the AES128 block cipher cipher = AES.new(key, AES.MODE_ECB) return cipher.encrypt(message_block) def aes_dec(key, ciphertext_block): if len(ciphertext_block) != 32: raise ValueError(&quot;AES message must be exactly 32 bytes!&quot;) # CAUTION: We do not actually use ECB mode! The cipher object needs a mode in order # to be initialized and since we want the &quot;pure&quot; permutation we initialize with ECB Mode # and always use it to encrypt blocks of size exactly 32. This is equivalent to running # the AES128 block cipher cipher = AES.new(key, AES.MODE_ECB) return cipher.decrypt(ciphertext_block) Note in the above how we make sure that we always encrypt one block (32 bytes). Next we show how to use the above code. # We use the aes128.sage recipe load(&#39;aes128.sage&#39;) # sample an aes128 key k = aes_keygen() # choose a random 32-byte long message to encrypt m = rand_bytes(32) # encrypt c = aes_enc(k, m) # decrypt m_prime = aes_dec(k, c) assert m == m_prime Modes of Operation: AES128-CBC Next we show how to use AES128 in CBC mode. Note that we do not handle padding for the sake of simplicity. We make sure that we always encrypt a multiple of block size bytes (32 in this case). # We use the aes128.sage recipe load(&#39;aes128.sage&#39;) def aes_cbc_enc(key, message): &quot;&quot;&quot; Runs the AES128 encryption on a message using CBC mode with the specified key. The length of message must be a multiple of 32. &quot;&quot;&quot; if len(message) % 32 != 0: raise ValueError(&quot;Message length must be a multiple of 32&quot;) block_size = 32 # Sample a random IV iv = rand_bytes(block_size) n_blocks = len(message) / block_size # Initialize ciphertext with the iv (corresponding to c_0) ciphertext = iv # We need to compute c_i = Enc_k(m_i XOR c_{i-1}) for i in range(n_blocks): # c_{i-1} c_prev = ciphertext[i * block_size : (i+1) * block_size] # m_i m_chunck = message[i * block_size : (i+1) * block_size] # m_i XOR c_{i-1} block_input = xor_bytes(c_prev, m_chunck) # Enc(k, m_i XOR c_{i-1}) and add it to the ciphertext ciphertext += aes_enc(key, block_input) return ciphertext def aes_cbc_dec(key, ciphertext): &quot;&quot;&quot; Runs the AES128 decryption on a message using CBC mode with the specified key. The length of the ciphertext must be a multiple of 32. &quot;&quot;&quot; if len(ciphertext) % 32 != 0: raise ValueError(&quot;ciphertext length must be a multiple of 32&quot;) block_size = 32 # To compute the number of block we subtract 1 corresponding to the IV n_blocks = len(ciphertext) / block_size - 1 message = b&#39;&#39; # We need to compute m_i = Dec_k(c_i) XOR c_{i-1} for i in range(n_blocks): # c_{i-1} c_prev = ciphertext[i * block_size : (i + 1) * block_size] # c_{i} c = ciphertext[(i + 1) * block_size : (i + 2) * block_size] # Dec_k(c_i) dec_c = aes_dec(key, c) # Dec_k(c_i) XOR c_{i-1} and add it to the message message += xor_bytes(dec_c, c_prev) return message Next, we demonstrate how to use the above code. # We use the aes_cbc.sage recipe load(&#39;aes_cbc.sage&#39;) # sample an aes128 key k = aes_keygen() # choose a random 100 * 32-byte long message to encrypt m = rand_bytes(100 * 32) # encrypt c = aes_cbc_enc(k, m) # decrypt m_prime = aes_cbc_dec(k, c) assert m == m_prime Modes of Operation: AES128-Counter We do the same thing but for counter mode of operation. # We use the aes128.sage recipe load(&#39;aes128.sage&#39;) def aes_counter_enc(key, message): &quot;&quot;&quot; Runs the AES128 encryption on a message using counter mode with the specified key. The length of message must be a multiple of 32. &quot;&quot;&quot; if len(message) % 32 != 0: raise ValueError(&quot;Message length must be a multiple of 32&quot;) block_size = 32 # Sample a random IV used as the counter iv = rand_bytes(block_size) n_blocks = len(message) / block_size # Initialize ciphertext with the counter ciphertext = iv # We need to compute c_i = m_i XOR Enc_k(counter + i) for i in range(n_blocks): # m_i m_chunk = message[i * block_size : (i+1) * block_size] # counter + i counter = (int.from_bytes(iv) + i).to_bytes(32) # Enc_k(counter + i) encrypted_counter = aes_enc(key, counter) # m_i XOR Enc_k(counter + i) ciphertext += xor_bytes(m_chunk, encrypted_counter) return ciphertext def aes_counter_dec(key, ciphertext): &quot;&quot;&quot; Runs the AES128 decryption on a ciphertext using counter mode with the specified key. The length of ciphertext must be a multiple of 32. &quot;&quot;&quot; if len(ciphertext) % 32 != 0: raise ValueError(&quot;Ciphertext length must be a multiple of 32&quot;) block_size = 32 # extract the iv iv = ciphertext[:block_size] # To compute the number of block we subtract 1 corresponding to the counter n_blocks = len(ciphertext) / block_size - 1 message = b&#39;&#39; # We need to compute m_i = c_i XOR Enc_k(counter + i) # Note that counter mode does not need decryption. for i in range(n_blocks): # c_i c_chunk = ciphertext[(i + 1) * block_size : (i + 2) * block_size] # counter + i counter = (int.from_bytes(iv) + i).to_bytes(32) # Enc_k(counter + i) encrypted_counter = aes_enc(key, counter) # c_i XOR Enc_k(counter + i) message += xor_bytes(c_chunk, encrypted_counter) return message And here is how you can use the above code: # We use the aes128.sage recipe load(&#39;aes_counter.sage&#39;) # sample an aes128 key k = aes_keygen() # choose a random 100 * 32-byte long message to encrypt m = rand_bytes(100 * 32) # encrypt c = aes_counter_enc(k, m) # decrypt m_prime = aes_counter_dec(k, c) assert m == m_prime Hash Functions Finally, we show how to use hash functions with the help of hashlib library. The library supports various different functions so you can easily change the hash function choice if you need to. import hashlib # Hashlib supports various hash functions. List them algorithms = hashlib.algorithms_available msg = b&quot;I need to be hashed. Please use sha256 to hash me&quot; # if it is an str instead of bytes use msg.encode() sha256_digest = hashlib.sha256(msg).hexdigest() E.4 Number theory In this subsection we demonstrate how to use sage for some very basic number theory. Sampling Random Primes A recipe to sample random primes of specific bitlength (meaning they need at least these many bits to be represented). bit_length = 1024 lower_bound = 2^(bit_length-1) upper_bound = 2^(bit_length)-1 p = random_prime(lower_bound, upper_bound) Factoring The next recipe factors numbers. Try to see how big numbers you can sample in a reasonable amount of time! # We can simply use the built in function factor n = 720 factorization = factor(n) Primality Testing We next show how to do primality testing in sage. Note that we simply use the in keyword that checks membership in a set. assert (7 in Primes()) assert not(8 in Primes()) Extended Euclidian Algorithm The next recipe shows how to run the (Extended) Euclidian Algorithm in sage. a = 20 b = 35 # Compute the greatest common divisor of a and b d = gcd(a, b) assert d == 5 # Check coprimality are_coprimes = (gcd(a,b) == 1) assert are_coprimes == false # Compute d, x, y s.t. d = ax + by and d is the greatest # common divisor of a and b (d, x, y) = xgcd(a, b) assert d == x*a + y*b Modular Arithmetic Finally, we show how to do efficient modular arithmetic in sage. It is basically enough to define the correct ring (numbers mod n with addition and multiplication mod n) and then work just as you would in integer arithmetic. You don’t even need to care about efficiency, sage knows that it should use -for example- fast exponentiation when you exponentiate on this ring. # Define integers ring Z17 Z17 = Integers(17) # Define elements a = Z17(3) b = Z17(15) # Addition add = a + b assert add == 1 # Subtraction sub = a - b assert sub == 5 # Multiplication mul = a * b assert mul == 11 # Inversion inv_a = a^(-1) assert inv_a == 6 # Exponentiation exp = a^3 assert exp == 10 # Solve linear equation 15x = 3 mod n sol = a * b^(-1) E.5 Groups and Fields We next show how to use sage to work with groups and fields. This is actually more useful in symbolic calculations rather than with cryptography, but it is useful to familiarize with the interface a bit. Additive Groups We showcase how to handle groups whose operation is denoted additively. # Define the group (Z11, +) G = AdditiveAbelianGroup([11]) # list the elements of G list(G) # get the default generator g = G.gens()[0] # identity element e = G.identity() # group operation h1 = g + g h2 = 7*g # equals g + g + g + g + g+ g + g # adding the identity element h3 = h2 + e assert h3 == h2 # inversion invh1 = -h1 assert invh1 + h1 == e # order of G ordG = G.order() assert ordG == 11 # random element hrandom = G.random_element() Unit Groups Same thing for unit groups. For our purposes we only care for \\(\\mathbb{Z}_n^*\\) unit groups, meaning the invertible elements \\(\\mod n\\). Note that sage treats these elements abstractly (as $f, f^2,…) for a formal variable f representing a group generator. We use the inject_variables command to bring this symbol in scope. We can then see the actual \\(\\mathbb{Z}_p^*\\) element corresponding to \\(f^i\\) as Zn(f^i) where Zn is our ring. # Define the ring (Z11, +, *) Z11 = Integers(11) # Define the group (Z11, *) G = Integers(11).unit_group() # list the elements of G w.r.t. a generator. # Note that this gives a list [1, f, f^2, ...] list(G) # To see actual elements, we need to map f^i to an element # in the ring # This brings to scope the variable f G.inject_variables() # We can now map f to a ring element h = Z11(f^2) assert h == 4 # get the default generator g = G.gens()[0] assert g == f # get the first generator # g = generators[0] # identity element e = G.identity() # group operation h1 = g * g assert Z11(h1) == 4 h2 = g^7 # equals g * g * g * g * g * g * g assert Z11(h2) == (2^7) % 11 h3 = h2 * e assert h3 == h2 # inversion invh3 = h3^(-1) assert invh3 * h3 == e # order of G ordG = G.order() assert ordG == 10 # random element hrandom = G.random_element() # order of an element ord_h3 = h3.order() # list subgroups # Note that G is of order 10 = 2 * 5. It has: # - a (trivial) subgroup of size 1 # - a subgroup of size 2 # - a subgroup of size 5 # - a subgroup of size 2*5 # The output gives a list: # [Multiplicative Abelian subgroup isomorphic to C2 x C5 generated by {f}, # Multiplicative Abelian subgroup isomorphic to C5 generated by {f^2}, # Multiplicative Abelian subgroup isomorphic to C2 generated by {f^5}, # Trivial Abelian subgroup] G.subgroups() # Get the subgroupof of order 5 H = G.subgroups()[2] # Get the subgroup defined by f^5 # We rename the generator to h5 since we already have f H5 = G.subgroup([f^5], &#39;h5&#39;) H5.inject_variables() assert h5 == f^5 # membership in subgroup assert (f^10 in H5) assert not(f^8 in H5) Finite Fields Finally we show how to work with finite fields. Recall that a field is a prime field (\\(\\mathbb{Z}_p\\) for a prime \\(p\\)) or it is represented by polynomials. In the second case, we can choose the formal variable symbol. # Define the prime field Z11 F11 = GF(11) # Define the galois field 5^4 # An optional argument can be given to define the variable name F = GF(5^4, &#39;x&#39;) # get the modulus used F.modulus() # get additive and multiplicative generator g_add = F.gen() g_mul = F11.multiplicative_generator() # we can do the normal operations as usual f1 = list(F)[2] f2 = list(F)[7] f3 = list(F)[10] f4 = (f1 + f2) * f3^(-1) # Define field elements. Note they are reduced mod F.modulus() p = F(&quot;x^10 + 3*x^2 + 1&quot;) q = F(&quot;3*x^5 + 1&quot;) r = p*q + f2^(-1) # additive and multiplicative order of elements ord_f1 = f1.order() mord_f1 = f1.multiplicative_order() # random element frandom = F.random_element() E.6 Polynomials In this subsection we show how to use sage to handle polynomials. Basic Polynomials Operations We first show how to define and do basic operations on polynomials. Note that whenever you work with polynomials, you should define a field over which the coefficients live, for example \\(\\mathbb{Z}_2\\) or \\(\\mathbb{R}\\). For our use-cases, we will work with polynomials with coefficients in \\(\\mathbb{Z}_p\\) for prime \\(p\\). # Define the polynomial ring over a field # Here we define F_17[x] (polynomials over GF(17) with formal variable x) R.&lt;x&gt; = PolynomialRing(GF(17)) f = x^3 + 2*x^2 + 1 g = 4*x^4 + 3*x +6 h = 8*x + 1 # We can do operations as expected p = f^2 - g + h*g # We can also compute quotients and remainders quot = p//h rem = p % h assert p == h * quot + rem # Evaluate a polynomial v = h(x=3) assert v == (8*3 + 1) % 17 q = x^2 - 1 Extended Euclidian Algorithm for Polynomials We next show how to run the Extended Euclidian Algorithm on polynomials. Note that sage is clever enough to know how to do this on each own, simply use the xgcd algorithm and give appropriate inputs. If the inputs are polynomials, it will run the polynomial version and if integers the integer version! # Define the polynomial ring over Integers R.&lt;x&gt; = PolynomialRing(ZZ) p = x^8 + 6*x^4 + x q = 4*x^2 # Find the greatest common divisor d = gcd(p, q) # Run the Extended Euclidian Algorithm (dd, xx, yy) = xgcd(p, q) assert dd == xx*p + yy*q Polynomial Interpolation Finally, we show how to interpolate polynomials. Recall this means finding the minimal degree polynomial that “crosses” a set of points. We also show how to find Lagrange polynomials. This is interpolation over specific sets: given x coordinates, the \\(i\\)-th Lagrange polynomial is 0 in all the points except the \\(i\\)-th, where it evaluates to 1. # Define the polynomial space R = PolynomialRing(GF(17), &#39;x&#39;) # Define the set of points points = [(5,1), (6,8), (9,12)] # Find the interpolating polynomial p = R.lagrange_polynomial(points) # Verify the result assert_cond = (p.degree() &lt; 3 and p(x=5) == 1 and p(x=6) == 8 and p(x=9) == 12) assert assert_cond # Given a set of x coordinates, find the lagrange polynomials x_coord = [5, 6, 9] # l5 points = [(5,1), (6,0), (9,0)] l1 = R.lagrange_polynomial(points) points = [(5,0), (6,1), (9,0)] l2 = R.lagrange_polynomial(points) points = [(5,0), (6,0), (9,1)] l3 = R.lagrange_polynomial(points) assert p == l1 * 1 + l2 * 8 + l3 * 12 E.7 RSA In this subsection we present various recipes related to RSA. Note that some parts (for example choosing a modulus) are used in all of them. Sampling an RSA Modulus We first show how to sample an RSA modulus. This is basically sampling two fixed length prime number and multiplying them. # Define the security parameter (bits of the modulus) secparam = 2048 # To achieve secparam modulus n = p*q, p and q must be secpara/2 bits long prime_length = secparam/2 lower_bound = 2^(prime_length-1) upper_bound = 2^(prime_length)-1 p = random_prime(lower_bound, upper_bound) q = random_prime(lower_bound, upper_bound) N = p*q Sampling an RSA key-pair We next show how to sample a full RSA key-pair. We need to sample the modulus as before and additionally compute the \\(e,d\\) pair of RSA. def rsa_keygen(secparam): &quot;&quot;&quot; Takes the secparam and returns an RSA secret/public key pair The output is given as two dictionaries: sk = {&quot;p&quot;: p, &quot;q&quot;: q, &quot;d&quot;: d} pk = {&quot;N&quot;: N, &quot;e&quot;: e} &quot;&quot;&quot; # Sample an RSA modulus prime_length = secparam // 2 lower_bound = 2^(prime_length-1) upper_bound = 2^(prime_length)-1 p = random_prime(lower_bound, upper_bound) q = random_prime(lower_bound, upper_bound) N = p * q #compute phi(N) phi = (p - 1) * (q - 1) # Sample a random e that is invertible mod phi_N. # One can also use other ways (e.g. e = 2^16 - 1) e = randrange(1, N) while gcd(e, phi) != 1: e = randrange(1, N) d = pow(e, -1, phi) # p, q are not actually needed sk = {&quot;p&quot;: p, &quot;q&quot;: q, &quot;d&quot;: d} pk = {&quot;N&quot;: N, &quot;e&quot;: e} return (sk, pk) Textbook RSA Encryption In the next recipe we implement the “textbook” RSA encryption scheme. Recall that this is completely insecure (any deterministic encryption scheme is!). # We use the rsa_keygen.sage recipe load(&#39;rsa_keygen.sage&#39;) def textbook_rsa_encrypt(pk, message): &quot;&quot;&quot; Encrypts an RSA message as m^e mod N. The message must be an Integers(N) element. We assume the pk is of the form output by rsa_keygen. &quot;&quot;&quot; return message^(pk[&#39;e&#39;]) def textbook_rsa_decrypt(sk, ciphertext): &quot;&quot;&quot; Decrypts an RSA ciphertext as c^d mod N. The ciphertext must be an Integers(N) element. We assume the sk is of the form output by rsa_keygen. &quot;&quot;&quot; return ciphertext^(sk[&#39;d&#39;]) Here is how to use the above for encryption/decryption. # We use the textbook_rsa.sage recipe load(&#39;textbook_rsa.sage&#39;) # Create a key sk, pk = rsa_keygen(2048) # Define ZN N = pk[&#39;N&#39;] ZN = Integers(N) # Define the message to be encrypted m = ZN(42) # encrypt c = textbook_rsa_encrypt(pk, m) # decrypt m_prime = textbook_rsa_decrypt(sk, c) assert m == m_prime RSA-FDH Signatures The next recipe implements RSA full domain hash signatures. We use the SHA256 from hashlib for the hash function. import hashlib # We use the rsa_keygen.sage recipe to sample keys load(&#39;rsa_keygen.sage&#39;) def rsa_sign(sk, m): &quot;&quot;&quot; Signs a message using RSA full domain hash with sha256 as the hash function. The message m can be any string. We assume the sk is of the form output by rsa_keygen. &quot;&quot;&quot; # hash the message digest = hashlib.sha256(m.encode()).hexdigest() # convert the digest to an integer by reading it as a hex number digest = int(&#39;0x&#39;+ digest, 16) # and finally convert it to Zn element p, q = sk[&#39;p&#39;], sk[&#39;q&#39;] # represent the number as a ZN element N = p * q ZN = Integers(N) digest = ZN(digest) d = sk[&#39;d&#39;] return digest^d def rsa_verify(pk, m, signature): &quot;&quot;&quot; Verifies a signature using RSA full domain hash with sha256 as the hash function. The message m can be any string. We assume the pk is of the form output by rsa_keygen. &quot;&quot;&quot; # hash the message digest = hashlib.sha256(m.encode()).hexdigest() # convert the digest to an integer by reading it as a hex number digest = int(&#39;0x&#39;+ digest, 16) # and finally convert it to Zn element p, q = sk[&#39;p&#39;], sk[&#39;q&#39;] N = p * q ZN = Integers(N) digest = ZN(digest) e = pk[&#39;e&#39;] return signature^e == digest Next we show how to use the above to sign messages and verify signatures. # We use the rsa_sha_signature.sage recipe to sample keys load(&#39;rsa_sha256_signatures.sage&#39;) # Create a key sk, pk = rsa_keygen(2048) m = &quot;&quot;&quot;This is a message whose authenticity is crucial. My ElGamal key is: ({&#39;p&#39;: 8607589379706225605009318235670632502463991112012865771933407304935190017403, &#39;q&#39;: 4303794689853112802504659117835316251231995556006432885966703652467595008701, &#39;g&#39;: 3814814891600025220956964856350040994409974231368858236343451345844148462986, &#39;h&#39;: 5088131483015987373087418941552710750500206632061904706006805181556567516887}, 3659275803126012824071303245940415271044329304500778431458890743996297880993)&quot;&quot;&quot; # sign signature = rsa_sign(sk, m) # verify result = rsa_verify(pk, m, signature) assert result E.8 Safe Prime Groups In this subsection we implement recipes to handle “safe prime” groups. Recall that these are subgroups of \\(\\mathbb{Z}_p^*\\) for p prime, which have prime order \\(q\\). The relation between \\(p,q\\) is \\(p = kq+1\\) for some small \\(k\\) (we always use \\(k=2\\)). Sampling Safe Primes The next recipe shows how to sample safe primes. We do this by simply sampling a prime \\(q\\) and seeing if \\(2q+1\\) is also a prime. We repeat until we find one. def sample_prime(length): &quot;&quot;&quot; Samples a prime with length bits. &quot;&quot;&quot; lower_bound = 2^(length-1) upper_bound = 2^(length)-1 return random_prime(lower_bound, upper_bound) def sample_safe_prime(length): &quot;&quot;&quot; Samples a prime number of the form p = 2q + 1 s.t. q is also prime. p must have length bits. &quot;&quot;&quot; p = sample_prime(length) while not (((p - 1) // 2) in Primes()): p = sample_prime(length) return p Next we show how to use the above recipe. # We use the safe_primes.sage recipe load(&#39;safe_primes.sage&#39;) safe_prime = sample_safe_prime(128) assert (safe_prime in Primes()) q = (safe_prime - 1) // 2 assert (q in Primes()) Sampling a safe prime subgroup The next recipe samples the actual subgroup defined by a safe prime. Note that we also need to fix a generator g when defining the group. We represent the group by the tuple \\((p, q, g)\\), although \\(p\\) is actually not needed. def safeprime_group(sec_param): &quot;&quot;&quot; Samples a group of prime order q, which is a subgroup of Zp for p = 2q+1 and a generator. The output contains a dictionary with the description of the group and the subgroup and its generator &quot;&quot;&quot; # sample a safe prime lower_bound = 2^(sec_param-1) upper_bound = 2^(sec_param)-1 p = random_prime(lower_bound, upper_bound) while not (((p - 1) // 2) in Primes()): p = random_prime(lower_bound, upper_bound) # Define the units mod p Zp = Integers(p) # Sample random group elements until one has order q g = Zp.random_element() q = (p - 1) // 2 while g.multiplicative_order() != q: g = Zp.random_element() return {&#39;p&#39;: p, &#39;q&#39;: q, &#39;g&#39;: g} Here is how to use the above to sample a group # We use the sample_safeprime_group.sage recipe load(&#39;sample_safeprime_group.sage&#39;) # sample the groups G = safeprime_group(256) # access the elements p, q, g p = G[&#39;p&#39;] q = G[&#39;q&#39;] g = G[&#39;g&#39;] E.9 Diffie Hellman Key Exchange We next present the recipe for a Diffie Hellman key exchange over safe prime groups. # We use the sample_safeprime_group.sage recipe load(&#39;sample_safeprime_group.sage&#39;) def ddh_key_part(params): &quot;&quot;&quot; Computes a random a and the public g^a. params should contain the description of a safeprime group &quot;&quot;&quot; p, q, g = (params[&#39;p&#39;], params[&#39;q&#39;], params[&#39;g&#39;]) Zp = Integers(p) # secret part a = randrange(1,q) A = (g^a) return (a, A) def ddh_final_key(params, a, B): &quot;&quot;&quot; Given the secret part a and the recieved public part B computes the common key K=B^a &quot;&quot;&quot; p, q, g = (params[&#39;p&#39;], params[&#39;q&#39;], params[&#39;g&#39;]) Zp = Integers(p) return B^a Next we show how Alice a Bob would use the above to agree on a common key. # We use the ddh.sage recipe load(&#39;ddh.sage&#39;) # Alice choses parameters and sends them to bob params = safeprime_group(256) # Alice computes (a, A=g^a) and sends A to Bob (a, A) = ddh_key_part(params) # Bob computes (b, B=g^b) and sends B to Alice (b, B) = ddh_key_part(params) # Alice computes the final key K_alice = B^a # Bob computes the final key K_bob = A^b assert K_alice == K_bob E.10 ElGamal over Safe Prime Groups In this section we present recipes for the two variants (normal and lifted) of ElGamal encryption scheme over safe prime groups. Sampling ElGamal Keys First, we show a recipe for creating an ElGamal key pair. This is as simple as sampling a safeprime group and setting \\((sk = x, pk = g^x)\\) for a random key. # We use the sample_safeprime_group.sage recipe to sample parameters load(&#39;sample_safeprime_group.sage&#39;) # Sampling of keys is the same for both ElGamal and lifted ElGamal def elgamal_keygen(sec_param): # sample the group params = safeprime_group(256) (p, q, g) = (params[&#39;p&#39;], params[&#39;q&#39;], params[&#39;g&#39;]) # secret key x = randrange(1,q) # public key h = g^x pk = {&#39;p&#39;: p, &#39;q&#39;: q, &#39;g&#39;: g, &#39;h&#39;: h } return (pk, x) ElGamal Encryption In the next recipe, we implement ElGamal over a same prime group. # We use the sample_elgamal_keys.sage recipe load(&#39;sample_elgamal_keys.sage&#39;) def elgamal_encrypt(pk, m): &quot;&quot;&quot; Encrypts a message using ElGamal. Takes as input the public key pk containing p,q,g,h where - p, q are primes s.t. p = 2q + 1 - g is a generator of the q-size size subgroup of Zp - h is an element of the subgroup and the message m which is an element of the subgroup We assume the pk is a dictionary as defined in sample_elgamal_keys.sage &quot;&quot;&quot; p, q, g, h = (pk[&#39;p&#39;], pk[&#39;q&#39;], pk[&#39;g&#39;], pk[&#39;h&#39;]) Zp = Integers(p) # sample randomness r = randrange(1,q) c = (g^r, m*(h^r)) return c def elgamal_decrypt(sk, c): &quot;&quot;&quot; Decrypts a ciphertext using ElGamal. &quot;&quot;&quot; # We get p by computing the additive order of c[0]. Alternatively, # we can add this information on sk or use the pk in the decryption. p = c[0].additive_order() Zp = Integers(p) c1, c2 = c m = c2*c1^(-sk) return m Here is how one can use the above recipe to encrypt/decrypt using ElGamal. # We use the elgamal.sage recipe load(&#39;elgamal.sage&#39;) # Create an ElGamal key pair (pk, sk) = elgamal_keygen(256) # parse the public key p, q, g, h = (pk[&#39;p&#39;], pk[&#39;q&#39;], pk[&#39;g&#39;], pk[&#39;h&#39;]) Zp = Integers(p) # sample a random message # recall the message should be a *subgroup* element m = Zp.random_element() while m.multiplicative_order() != q: m = Zp.random_element() # encrypt the message c = elgamal_encrypt(pk, m) # decrypt the message m_prime = elgamal_decrypt(sk, c) assert m == m_prime Lifted ElGamal Encryption Next we present the lifted version of ElGamal. Essentially, the only changes are that: (1) the message is now a \\(\\mathbb{Z}_q\\) element in the exponent, (2) the decryption needs to bruteforce over a known domain to find the discrete log. # We use the elgamal_keys.sage recipe load(&#39;sample_elgamal_keys.sage&#39;) def lifted_elgamal_encrypt(pk, m): &quot;&quot;&quot; Encrypts a message using ElGamal. Takes as input the public key pk containing p,q,g,h where - p, q are primes s.t. p = 2q + 1 - g is a generator of the q-size size subgroup of Zp - h is an element of the subgroup and the message m which is an element of the subgroup &quot;&quot;&quot; p, q, g, h = (pk[&#39;p&#39;], pk[&#39;q&#39;], pk[&#39;g&#39;], pk[&#39;h&#39;]) Zp = Integers(p) # sample randomness r = randrange(1,q) c = (g^r, (g^m)*(h^r)) return c def lifted_elgamal_decrypt(sk, c, list): &quot;&quot;&quot; Decrypts a ciphertext using lifted ElGamal. It takes as additional input a list containing all the possible messages on which it bruteforces. &quot;&quot;&quot; # We get p by computing the additive order of c[0] (=p). Alternatively, # we can add this information on sk or use the pk in the decryption. p = c[0].additive_order() Zp = Integers(p) (c1, c2) = c g_pow_m = c2*c1^(-sk) # bruteforce to find the discrete logarithm for m in list: if g^m == g_pow_m: return m Here is how one can use the lifted version of ElGamal. # We use the lifted_elgamal_keys.sage recipe load(&#39;lifted_elgamal.sage&#39;) # Create an ElGamal key pair (pk, sk) = elgamal_keygen(256) # parse the public key p, q, g, h = (pk[&#39;p&#39;], pk[&#39;q&#39;], pk[&#39;g&#39;], pk[&#39;h&#39;]) Zp = Integers(p) Zq = Integers(q) # define the possible messages to be [0..1000) message_list = list(range(1000)) # choose a random message. Recall the message should be a Zq element! m = Zq(randrange(0,1000)) # encrypt the message c = lifted_elgamal_encrypt(pk, m) # decrypt the message m_prime = lifted_elgamal_decrypt(sk, c, message_list) assert m == m_prime E.11 Elliptic Curve Cryptography: secp256k1 Curve In these section we look into Elliptic Curve Cryptography. Specifically, we look into implementations over the secp256k1 curve. To understand the relevant recipes you need to keep in mind two things: The group defined by the curve is denoted additively, The operations are exactly the same as the ones in safeprimes groups. This means that if one replaces the group operation of multiplication \\(\\mod p\\) in the DH protocol for example with the group operation of the curve, one gets the DH protocol over the curve! Keep in mind how notation changes: Multiplication becomes addition. Exponentiation (many multiplications) becomes multiplication (many additions). The “exponents” in \\(\\mathbb{Z}_q\\) remain in \\(\\mathbb{Z}_q\\) (the order of the group in both cases). The subgroup elements of safeprimes (subset of \\(\\mathbb{Z}_p\\)) become points in the Elliptic Curve (pairs of elements of \\(\\mathbb{Z}_p\\) for a different prime \\(p\\)). Keep in mind that you do not need to know how the group operation works. You can simply forget about this and apply the operations correctly to get the corresponding protocols. secp256k1 Basic Operations The next recipe shows how to “sample” the curve. The sample is in quotations because the curve is actually fixed. You can find the curve specifications here. # secp256k1 is the elliptic curve defined by the equation # y^2 = x^3 + ax + b with a=0, b=7 over the prime field Fp # for p = 2^256 - 2^32 - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1 # # The curve contains the points (x, y) that satisfy the equation # y^2 = x^3 + ax + b over Fp # The number of these points are q for a prime q. This defines another # field Fq # # - The field Fp (where the coordinates are defined) is called *base field* # - The field Fq is called *scalar field* # # These points define an abelian group under elliptic curve addition operation # # The specifications of the curve define the element # G= ( # 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798, # 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8 # ) # as the generator of the group. # # The specifications of the curve can be found in # https://neuromancer.sk/std/secg/secp256k1 def secp256k1_params(): # first define the base field Fp p = 2^256 - 2^32 - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1 Fp = GF(p) # we next define the elliptic curve E = EllipticCurve(Fp, [0, 7]) # the scalar field contains the number of elements in the group (i.e. points) q = E.order() # finally, we define the generator Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798 Gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8 G = E(Gx, Gy) return (E, p, q, G) We next show how to sample the curve and make basic operations on it. # We use the secp256k1.sage recipe load(&#39;secp256k1.sage&#39;) # Define the curve (E, p, q, g) = secp256k1_params() # Let&#39;s first sample two random points by computing # xi and setting hi = xi g # scalars live in Fq Fq = GF(q) x1 = Fq.random_element() x2 = Fq.random_element() h1 = x1 * g h2 = x2 * g # Let&#39;s verify they are on curve assert h1 in E assert h2 in E # We can add group elements # this is &quot;equivalent&quot; to multiplying in safeprime groups h3 = h1 + h2 # and we we can do scalars operation # this is &quot;equivalent&quot; to exponentiation in safeprime groups h4 = 2 * h3 assert h4 == h3 + h3 # We can also invert elements h4inv = -h4 # The identity element is the point in infinity. e = E(0) assert h4inv + h4 == e Diffie Hellman Key Exchange over secp256k1 The next recipe implements the Diffie Hellman Key Exchange over secp256k1. Note that this is the same as in the safeprime groups if one turns “multiplications” into “additions”. # This is ddh over secp256k1. It works exactly as the ddh in safeprime groups # except that we are in the group. # We use the secp256k1.sage recipe load(&#39;secp256k1.sage&#39;) # We don&#39;t need sample params, we get them ready by secp256k1 specs def secp256k1_ddh_key_part(): &quot;&quot;&quot; Computes a random a in Fq and the public a*g. &quot;&quot;&quot; (E, p, q, g) = secp256k1_params() Fq = GF(q) # secret part a = Fq.random_element() A = a*g return (a, A) def secp256k1_ddh_final_key(a, B): &quot;&quot;&quot; Given the secret part a and the recieved public part B computes the common key K=a*B &quot;&quot;&quot; return a*B Next we show how Alice and Bob can use the above to agree on a key over the curve. # We use the secp256k1_ddh.sage recipe load(&#39;secp256k1_ddh.sage&#39;) # Alice computes (a, A=a*g) and sends A to Bob (a, A) = secp256k1_ddh_key_part() # Bob computes (b, B=b*g) and sends B to Alice (b, B) = secp256k1_ddh_key_part() # Alice computes the final key K_alice = a*B # Bob computes the final key K_bob = b*A assert K_alice == K_bob ElGamal Encryption over secp256k1 Next, we implement ElGamal over the curve. Again, this is implemented as ElGamal over safe prime groups, the only thing changing is the group! One can similarly implement the lifted version. Recall that for this one should use bruteforce to do the final decryption. # We use the secp256k1.sage recipe load(&#39;secp256k1.sage&#39;) def secp256k1_elgamal_keygen(): &quot;&quot;&quot; samples the elgamal key. We don&#39;t need to take the security parameter as input since we use a fixed curve &quot;&quot;&quot; # define the group (E, p, q, g) = secp256k1_params() # secret key Fq = GF(q) x = Fq.random_element() # public key h = x*g return (h, x) def secp256k1_elgamal_encrypt(pk, m): &quot;&quot;&quot; Encrypts a message using ElGamal over secp256k1. &quot;&quot;&quot; # define the group (E, p, q, g) = secp256k1_params() # sample randomness # secret key Fq = GF(q) r = Fq.random_element() c = (r*g, r*pk + m) return c def secp256k1_elgamal_decrypt(sk, c): &quot;&quot;&quot; Decrypts a ciphertext using ElGamal over secp256k1. &quot;&quot;&quot; c1, c2 = c m = c2-sk*c1 return m We next show how encryption and decryption works. # We use the secp256k1_elgamal.sage recipe load(&#39;secp256k1_elgamal.sage&#39;) # Define the curve (E, p, q, g) = secp256k1_params() # Create an ElGamal key pair (pk, sk) = secp256k1_elgamal_keygen() # sample a random message # the message in a curve element m = 42*g # encrypt the message c = secp256k1_elgamal_encrypt(pk, m) # decrypt the message m_prime = secp256k1_elgamal_decrypt(sk, c) assert m == m_prime E.12 Secret Sharing In this subsection we present implementations for the two variants of secret sharing we have seen. Simple Secret Sharing Next, we implement the simple secret sharing (share \\(s\\) as \\(s_1, s\\oplus s_1\\) for a random \\(s_1\\)). def simple_share(s): &quot;&quot;&quot; Shares a secret s to 2 parties s.t. both need to collaborate to reconstruct. The secret is a string. &quot;&quot;&quot; # convert the secret to bytes s_encoded = s.encode() # get the length of the secret length = len(s_encoded) # sample random bytes of the same length as s. This is the first share s1 = b&#39;&#39;.join(randrange(0,256).to_bytes() for _ in range(length)) # create the second share as s XOR s1 s2 = bytes(x ^^ y for x, y in zip(s1, s_encoded)) return (s1, s2) def simple_reconstruct(s1, s2): &quot;&quot;&quot; Reconstructs a shared secret. It takes the shares (byte streams) of both parties and gets the secret &quot;&quot;&quot; s_encoded = bytes(x ^^ y for x, y in zip(s1, s2)) return s_encoded.decode() We showcase next the above by sharing our secret message. # We use the simple_secret_sharing.sage recipe load(&#39;simple_secret_sharing.sage&#39;) # Choose a secret s = &quot;The secret number is 42.&quot; # share to the parties (s1, s2) = simple_share(s) # reconstruct s_prime = simple_reconstruct(s1, s2) assert s == s_prime Shamir Secret Sharing The next recipe implements Shamir’s secret sharing scheme. It would be useful to recall the polynomial recipes before looking into the next one. def shamir_share(F, s, t, n): &quot;&quot;&quot; Shares a secret s over field F. t &lt;= n is the threshold. The public points used are always 1, ..., n &quot;&quot;&quot; # Choose a random polynomial of degree t-1 # We do this by sampling t-1 random coefficients coeff = list(F.random_element() for _ in range(t-1)) # Define the polynomial space R.&lt;x&gt; = PolynomialRing(F) # construct the polynomial p = s for i in range(t-1): p += coeff[i] * (x^(i+1)) # evaluate the polynomial at every point 1,...,n return list((i, p(x=i)) for i in range(1, n+1)) def shamir_reconstruct(F, points): &quot;&quot;&quot; Reconstructs a shared secret over field F. It takes the shares (points) of enough parties and gets the secret &quot;&quot;&quot; # Define the polynomial space R.&lt;x&gt; = PolynomialRing(F) # interpolate points to find the polynomial p = R.lagrange_polynomial(points) # evaluate at 0 to learn the secret return p(x=0) We next show how to share a secret using this scheme. # We use the shamir_secret_sharing.sage recipe load(&#39;shamir_secret_sharing.sage&#39;) # Define a field bit_length = 128 lower_bound = 2^(bit_length-1) upper_bound = 2^(bit_length)-1 p = random_prime(lower_bound, upper_bound) F = GF(p) # sample a random secret s = F.random_element() # share to 10 parties s.t. at least 4 are needed to reconstruct shares = shamir_share(F, s, 4, 10) # parties 4, 7, 9, 10 try to reconstruct the secret # recall we have points 1, 2, ... 10 but we count from 0 points = [shares[3], shares[6], shares[8], shares[9]] s_prime = shamir_reconstruct(F, points) assert s == s_prime E.13 Threshold Cryptography In this subsection we combine Shamir’s secret sharing with ElGamal encryption to implement threshold ElGamal over safe prime groups. Try to make them work over secp256k1! Threshold ElGamal We next present the threshold ElGamal recipe. Note how the parties do not need to reconstruct the secret key to decrypt. # We use the elgamal.sage and shamir_secret_sharing.sage recipes. # Recall that encryption is exactly as ElGamal load(&#39;shamir_secret_sharing.sage&#39;) load(&#39;elgamal.sage&#39;) def compute_weight(F, other_x, x_i, y_i): &quot;&quot;&quot; Helper function to copmute the &quot;weight&quot;. This equals to y_i * l(0) where l is the lagrange polynomial over F associated with all the x points. Specifically, it is the polynomial that: - is 0 on all x in other_x - is 1 on x_i &quot;&quot;&quot; # Create the points points = [(x, 0) for x in other_x] # 0 on other_x points.append((x_i, 1)) # 1 on x_i # interpolate to find l and evaluate to 0 R.&lt;x&gt; = PolynomialRing(F) l = R.lagrange_polynomial(points)(x=0) # return the result return l*y_i def elgamal_partial_decrypt(c1, w): &quot;&quot;&quot; Partially decrypts an ElGamal ciphertext. Takes as input the weight w = l * y_i, and the first part of the ciphertext c1 and outputs an updated c1^w. &quot;&quot;&quot; return c1^w Next we show how to use the above recipe to threshold-decrypt an ElGamal encrypted message. # We use the threshold_elgamal.sage recipe load(&#39;threshold_elgamal.sage&#39;) # Create an ElGamal key pair (pk, sk) = elgamal_keygen(256) # parse the public key p, q, g, h = (pk[&#39;p&#39;], pk[&#39;q&#39;], pk[&#39;g&#39;], pk[&#39;h&#39;]) Zp = Integers(p) # get also the field F_q # The key is an F_q element so this is the correct field F = GF(q) # Secret share the public key to 12 parties, 3 of which # must collaborate to decrypt shares = shamir_share(F, sk, 3, 12) # encrypt a random message # recall the message should be a *subgroup* element m = Zp.random_element() while m.multiplicative_order() != q: m = Zp.random_element() # encrypt the message (c1, c2) = elgamal_encrypt(pk, m) # parties 1, 6, 7 want to decrypt c # Party 1 computes the partial decryption y1 = shares[0][1] w1 = compute_weight(F, [6,7], 1, y1) # Partial decryption c1_1 = elgamal_partial_decrypt(c1, w1) # Party 6 computes the partial decryption y6 = shares[5][1] w6 = compute_weight(F, [1,7], 6, y6) # Partial decryption c1_6 = elgamal_partial_decrypt(c1, w6) # Party 7 computes the partial decryption y7 = shares[6][1] w7 = compute_weight(F, [1,6], 7, y7) # Partial decryption c1_7 = elgamal_partial_decrypt(c1, w7) # The parties share the partial decryptions with each other # Each party can now combine them alpha = c1_1 * c1_6 * c1_7 # and decrypt m_prime = c2 * alpha^(-1) # in case of lifted el gamal everything is the shame, except that # now we need to brute force c2 * c1^(-1) to get the actual message assert m == m_prime E.14 Zero Knowledge Proofs In this section we present the Schnorr protocol for proving knowledge of discrete logarithms. We do this over secp256k1 just for the fun of it. It is easy to adapt it to safe prime groups. Schnorr Protocol over secp256k1 We next present the prove and verify algorithms for the Schnorr protocol. To derive the Fiat-Shamir challenge we use the SHA256 implementation of hashlib. Note how we hash the curve specs and the statement to derive the challenge. The prover should always hash all the information exchanged by both parties! # HVZK proof to prove knowledge of the discrete logarithm of an # element in secp256k1 curve. SHA256 is used as a hash function # import sha256 from hashlib import sha256 ### def schnorr_prove(h, x): &quot;&quot;&quot; Create a proof pi that h = x*g &quot;&quot;&quot; # Define the curve and the scalar field (E, p, q, g) = secp256k1_params() Fq = GF(q) # We first sample a random element r and the element r*g r = Fq.random_element() u = r * g # We know should get the random challenge. We compute it # by hashing H(&quot;secp256k1&quot;, h, u). hash_input = &#39;secp256k1&#39; + str(h) + str(u) digest = sha256(hash_input.encode()).hexdigest() # q has ~256 bits and the digest is exactly 256 bits. We therefore # keep only 252 bits of the ouptut to create c. Note that we encode # the message as an Fq element c = Fq(int(&#39;0x&#39;+ digest[:-1], 16)) # Finally we create the last message z z = r + c*x # We output the proof. Note that c is not included since the verifier # can compute it on its own proof = (u, z) return proof def schnorr_verify(h, proof): &quot;&quot;&quot; verify a proof of knowledge of dlog of h &quot;&quot;&quot; # Define the curve and the scalar field (E, p, q, g) = secp256k1_params() Fq = GF(q) (u, z) = proof # We compute the hash as the prover given hash_input = &#39;secp256k1&#39; + str(h) + str(u) digest = sha256(hash_input.encode()).hexdigest() c = Fq(int(&#39;0x&#39;+ digest[:-1], 16)) # Finally we do the final verification by checking the # equation zg = ch+u return z*g == c*h + u Next we present an actual run of the protocol for a random statement. Note that this is exactly the proof of knowledge of an ElGamal secret key over secp256k1! # We use the schnorr recipe load(&#39;schnorr.sage&#39;) # define the curve and Fq (E, p, q, g) = secp256k1_params() Fq = GF(q) # sample a random element x = Fq.random_element() # define the statement h h = x*g # Create a proof of knowledge of dlog of h proof = schnorr_prove(h, x) # verify the proof assert schnorr_verify(h, proof) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
